<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon.ico?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon.ico?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="ls是目录操作命令，主要作用是显示目录下的内容。 ls -[参数]-a 显示所有的文件名-d 显示目录信息，而-不是目录下的文件-h 人性化显示，按照我们习惯的单位显示文件大小-i 显示文件的i节点号-l 长格式显示"><meta property="og:type" content="article"><meta property="og:title" content="linux 笔记"><meta property="og:url" content="https://bfch.github.io/2020-10-15/31/index.html"><meta property="og:site_name" content="Anew忘"><meta property="og:description" content="ls是目录操作命令，主要作用是显示目录下的内容。 ls -[参数]-a 显示所有的文件名-d 显示目录信息，而-不是目录下的文件-h 人性化显示，按照我们习惯的单位显示文件大小-i 显示文件的i节点号-l 长格式显示"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-10-15T11:26:35.960Z"><meta property="article:modified_time" content="2020-10-27T01:09:53.470Z"><meta property="article:author" content="Anew忘"><meta name="twitter:card" content="summary"><meta name="keywords" content="Anew忘, Anew忘"><meta name="description" content=""><title>linux 笔记 | Anew忘</title><link ref="canonical" href="https://bfch.github.io/2020-10-15/31/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun=window.Stun||{},CONFIG={root:"/",algolia:void 0,fontIcon:{prompt:{success:"fas fa-check-circle",info:"fas fa-arrow-circle-right",warning:"fas fa-exclamation-circle",error:"fas fa-times-circle"},copyBtn:"fas fa-copy"},sidebar:{offsetTop:"20px",tocMaxDepth:6},header:{enable:!0,showOnPost:!0,scrollDownIcon:!1},postWidget:{endText:!0},nightMode:{enable:!0},back2top:{enable:!0},codeblock:{style:"default",highlight:"light",wordWrap:!1},reward:!1,fancybox:!0,zoomImage:{gapAside:"20px"},galleryWaterfall:void 0,lazyload:!1,pjax:{avoidBanner:!1},externalLink:{icon:{enable:!0,name:"fas fa-external-link-alt"}},shortcuts:void 0,prompt:{copyButton:"复制",copySuccess:"复制成功",copyError:"复制失败"},sourcePath:{js:"js",css:"css",images:"images"}};window.CONFIG=CONFIG</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return!1"><span class="header-nav-menu-item__icon"><i class="fas fa-feather-alt"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fa fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return!1"><span class="header-nav-menu-item__icon"><i class="fas fa-angle-double-down"></i></span><span class="header-nav-menu-item__text">其他</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/gallery/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/friends/"><span class="header-nav-submenu-item__icon"><i class="fas fa-hand-spock"></i></span><span class="header-nav-submenu-item__text">友链</span></a></div></div></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Anew忘</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">linux 笔记</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-10-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-10-27</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><ol><li>ls是目录操作命令，主要作用是显示目录下的内容。 ls -[参数]</li><li>-a 显示所有的文件名</li><li>-d 显示目录信息，而-不是目录下的文件</li><li>-h 人性化显示，按照我们习惯的单位显示文件大小</li><li>-i 显示文件的i节点号</li><li>-l 长格式显示<a id="more"></a></li></ol><p>第四章：常用命令<br>一 命令的基本格式</p><ol><li>命令的提示符<br>[root@localhost ~]#<br>[]：这是提示符的分隔符号，没有特殊含义。<br>root：显示的是当前的登录用户，超哥现在使用的是 root 用户登录。<br>@：分隔符号，没有特殊含义。<br>localhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）。<br>~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。<br>#：命令提示符。超级用户是#，普通用户是$</li><li>命令的基本格式<br>[root@localhost ~]# 命令 [选项] [参数]<br>ls 是最常见的目录操作命令，主要作用是显示目录下的内容。<br>命令名称：ls。<br>英文原意：list。<br>所在路径：/bin/ls。<br>执行权限：所有用户。<br>功能描述：显示目录下的内容。 [root@localhost ~]#ls [选项] [文件名或目录名]<br>选项：</li></ol><p>-a: 显示所有文件<br>–color=when:支持颜色输出，when的值默认是 always（总显示颜色），也可以是<br>never（从不显示颜色）和 auto（自动）<br>-d： 显示目录信息，而不是目录下的文件<br>-h： 人性化显示，按照我们习惯的单位显示文件大小<br>-i： 显示文件的 i节点号<br>-l： 长格式显示<br>举几个例子：<br>[root@localhost ~]# ls -l 总用量 44</p><p>—————————————————————————————<br>-rw——-. 1 root root 1207 1月 14 18:18 anaconda-ks.cfg<br>#权限 引用计数 所有者 所属组 大小 文件修改时间 文件名<br>我们已经知道“-l”选项用于显示文件的详细信息，那么“-l”选项显示的这 7 列分别是什么含义？<br>第一列：权限。具体权限的含义将在 4.5 节中讲解。<br>第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录<br>有多少个一级子目录。<br>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户<br>第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。<br>第五列：大小。默认单位是字节。<br>第六列：文件修改时间。文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个<br>时间不是文件的创建时间。<br>第七列：文件名。<br>选项：是用于调整命令的功能的。<br>参数：是命令的操作对象，如果省略参数，是因为有默认参数<br>二 目录操作命令<br>1．ls 命令<br>见前一小节的内容。<br>2. cd 命令<br>cd 是切换所在目录的命令，这个命令的基本信息如下。<br>命令名称：cd。<br>英文原意：change directory。<br>所在路径：Shell 内置命令。<br>执行权限：所有用户。<br>功能描述：切换所在目录。<br>2.1 cd 命令的简化用法<br>特殊符号 作 用<br>~ 代表用户的家目录</p><ul><li>代表上次所在目录<br>. 代表当前目录<br>.. 代表上级目录</li></ul><p>2.2 绝对路径和相对路径<br>绝对路径：以跟目录为参照物，从根目录开始，一级一级进入目录</p><p>—————————————————————————————<br>相对路径：以当前目录作为参照物，进行目录查找<br>3．pwd 命令<br>pwd 命令是查询所在目录的命令，基本信息如下：<br>命令名称：pwd<br>英文原意：print name of current/working directory<br>所在路径：/bin/pwd<br>执行权限：所有用户。<br>功能描述：查询所在的工作目录。<br>4．mkdir 命令<br>mkdir 是创建目录的命令，其基本信息如下。<br>命令名称：mkdir。<br>英文原意：make directories。<br>所在路径：/bin/mkdir。<br>执行权限：所有用户。<br>功能描述：创建空目录。<br>命令格式<br>[root@localhost ~]# mkdir [选项] 目录名 选项：<br>-p： 递归建立所需目录<br>行。<br>5．rmdir 命令<br>既然有建立目录的命令，就一定会有删除目录的命令 rmdir，其基本信息如下。<br>命令名称：rmdir。<br>英文原意：remove empty directories。<br>所在路径：/bin/rmdir。<br>执行权限：所有用户。<br>功能描述：删除空目录。<br>命令格式<br>[root@localhost ~]# rmdir [选项] 目录名 选项：<br>-p： 递归删除目录</p><p>————————————————<br>rmdir 命令的作用十分有限，因为只能删除空目录，所以一旦目录中有内容，就会报错。<br>这个命令比较“笨”，所以我们不太常用。后续我们不论删除的是文件还是目录，都会使用 rm<br>命令<br>三 文件操作命令<br>1．touch 命令<br>创建空文件或修改文件时间，这个命令的基本信息如下。<br>命令名称：touch。<br>英文原意：change file timestamps。<br>所在路径：/bin/touch。<br>执行权限：所有用户。<br>功能描述：修改文件的时间戳。<br>2．stat 命令<br>stat 是查看文件详细信息的命令，而且可以看到文件的这三个时间，其基本信息如下。<br>命令名称：stat。<br>英文原意：display file or file system status。<br>所在路径：/usr/bin/stat。<br>执行权限：所有用户。<br>功能描述：显示文件或文件系统的详细信息。<br>[root@localhost ~]# stat anaconda-ks.cfg<br>文件：”anaconda-ks.cfg”<br>大小：1453 块：8 IO 块：4096 普通文件<br>设备：803h/2051dInode：33574991 硬链接：1<br>权限：(0600/-rw——-) Uid：( 0/ root) Gid：( 0/ root)<br>环境：system_u:object_r:admin_home_t:s0 最近访问：2018-11-06 23:22:23.409038121 +0800<br>最近更改：2018-10-24 00:53:08.760018638 +0800 #数据修改时间<br>最近改动：2018-10-24 00:53:08.760018638 +0800 #状态修改时间<br>创建时间：-<br>3．cat 命令<br>cat 命令用来查看文件内容。这个命令的基本信息如下。<br>命令名称：cat。<br>英文原意：concatenate files and print on the standard output。</p><p>———————————————<br>所在路径：/bin/cat。<br>执行权限：所有用户。<br>功能描述：合并文件并打印输出到标准输出<br>命令格式<br>[root@localhost ~]# cat [选项] 文件名 选项：<br>-A： 相当于-vET选项的整合，用于列出所有隐藏符号<br>-E：列出每行结尾的回车符$<br>-n： 显示行号<br>-T：把 Tab键用^I显示出来<br>-v：列出特殊字符<br>4．more 命令<br>more 是分屏显示文件的命令，其基本信息如下。<br>命令名称：more。<br>英文原意：file perusal filter for crt viewin。<br>所在路径：/bin/more。<br>执行权限：所有用户。<br>功能描述：分屏显示文件内容。<br>more 命令比较简单，一般不用什么选项，命令会打开一个交互界面，可以识别一些交互命令。常<br>用的交互命令如下。<br>空格键：向下翻页。<br>b：向上翻页。<br>回车键：向下滚动一行。<br>/字符串：搜索指定的字符串。<br>q：退出。<br>5．less 命令<br>less 命令和 more 命令类似，只是 more 是分屏显示命令，而 less 是分行显示命令，其基本信息如<br>下。<br>命令名称：less。<br>英文原意：opposite of more。<br>所在路径：/usr/bin/less。<br>执行权限：所有用户。<br>功能描述：分行显示文件内容<br>6．head 命令<br>head 是用来显示文件开头的命令，其基本信息如下。<br>命令名称：head。<br>英文原意：output the first part of files。</p><p>—————————————————————————————<br>所在路径：/usr/bin/head。<br>执行权限：所有用户。<br>功能描述：显示文件开头的内容。<br>1．命令格式<br>[root@localhost ~]# head [选项] 文件名 选项：<br>-n 行数： 从文件头开始，显示指定行数<br>-v： 显示文件名<br>7．tail 命令<br>既然有显示文件开头的命令，就会有显示文件结尾的命令。tail 命令的基本信息如下。<br>命令名称：tail。<br>英文原意：output the last part of files。<br>所在路径：/usr/bin/tail。<br>执行权限：所有用户。<br>功能描述：显示文件结尾的内容。<br>命令格式<br>[root@localhost ~]# tail [选项] 文件名 选项：<br>-n 行数： 从文件结尾开始，显示指定行数<br>-f： 监听文件的新增内容<br>8．ln 命令<br>我们来看看 ln 命令的基本信息。<br>命令名称：ln。<br>英文原意：make links between file。<br>所在路径：/bin/ln。<br>执行权限：所有用户。<br>功能描述：在文件之间建立链接。<br>8.1 ln 命令的基本格式如下：<br>[root@localhost ~]# ln [选项] 源文件 目标文件 选项：<br>-s：建立软链接文件。如果不加“-s”选项，则建立硬链接文件<br>-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件<br>如果创建硬链接：<br>[root@localhost ~]# touch cangls [root@localhost ~]# ln /root/cangls /tmp/<br>#建立硬链接文件，目标文件没有写文件名，会和原名一致<br>#也就是/root/cangls和/tmp/cangls是硬链接文件</p><p>——————————————————————————<br>如果创建软链接：<br>[root@localhost ~]# touch bols<br>[root@localhost ~]# ln -s /root/bols /tmp/ #建立软链接文件<br>8.2 硬链接与软连接的特征<br>硬链接特征：<br>源文件和硬链接文件拥有相同的 Inode和 Block<br>修改任意一个文件，另一个都改变<br>删除任意一个文件，另一个都能使用<br>硬链接标记不清，很难确认硬链接文件位置，不建议使用<br>硬链接不能链接目录<br>硬链接不能跨分区<br>软链接特征：<br>软链接和源文件拥有不同的 Inode和 Block<br>两个文件修改任意一个，另一个都改变<br>删除软链接，源文件不受影响；删除源文件，软链接不能使用<br>软链接没有实际数据，只保存源文件的 Inode，不论源文件多大，软链接大小不变<br>软链接的权限是最大权限 lrwxrwxrwx.，但是由于没有实际数据，最终访问时需要参考源文<br>件权限<br>软链接可以链接目录<br>软链接可以跨分区<br>软链接特征明显，建议使用软连接<br>四 目录和文件都能操作的命令<br>1．rm 命令<br>rm 是强大的删除命令，不仅可以删除文件，也可以删除目录。这个命令的基本信息如下。<br>命令名称：rm。<br>英文原意：remove files or directories。<br>所在路径：/bin/rm。<br>执行权限：所有用户。<br>功能描述：删除文件或目录。<br>命令格式<br>[root@localhost ~]# rm [选项] 文件或目录 选项：<br>-f： 强制删除（force）<br>-i： 交互删除，在删除之前会询问用户<br>-r： 递归删除，可以删除目录（recursive）</p><p>———————————————<br>2．cp 命令<br>cp 是用于复制的命令，其基本信息如下：<br>命令名称：cp。<br>英文原意：copy files and directories。<br>所在路径：/bin/cp。<br>执行权限：所有用户。heo<br>功能描述：复制文件和目录。<br>命令格式<br>[root@localhost ~]# cp [选项] 源文件 目标文件 选项：<br>-a： 相当于-dpr选项的集合，这几个选项我们一一介绍<br>-d： 如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接<br>-i： 询问，如果目标文件已经存在，则会询问是否覆盖<br>-p： 复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）<br>-r： 递归复制，用于复制目录<br>3．mv 命令<br>mv 是用来剪切的命令，其基本信息如下。<br>命令名称：mv。<br>英文原意：move (rename) files。<br>所在路径：/bin/mv。<br>执行权限：所有用户。<br>功能描述：移动文件或改名。<br>命令格式<br>[root@localhost ~]# mv [选项] 源文件 目标文件 选项：<br>-f： 强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖<br>-i： 交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项） -v： 显示详细信息<br>五 基本权限管理<br>1．权限的介绍<br>权限位的含义<br>前面讲解 ls 命令时，我们已经知道长格式显示的第一列就是文件的权限，例如：<br>[root@localhost ~]# ls -l install.log<br>-rw-r–r–. 1 root root 24772 1月 14 18:17 install.log<br>第一列的权限位如果不计算最后的“.”（这个点的含义我们在后面解释），则共有 10 位，这 10<br>位权限位的含义如图 4-4 所示。</p><p>———————————————————<br>图 4-4 权限位的含义<br>第 1 位代表文件类型。Linux 不像 Windows 使用扩展名表示文件类型，而是使用权限位的第 1<br>位表示文件类型。虽然 Linux 文件的种类不像 Windows 中那么多，但是分类也不少，详细情况<br>可以使用“info ls”命令查看。超哥在这里只讲一些常见的文件类型。</p><ul><li>“-”：普通文件。</li><li>“b”：块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件/dev/sda1<br>就是这种文件。</li><li>“c”：字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘<br>等。</li><li>“d”：目录文件。Linux 中一切皆文件，所以目录也是文件的一种。</li><li>“l”：软链接文件。</li><li>“p”：管道符文件。这是一种非常少见的特殊设备文件。</li><li>“s”：套接字文件。这也是一种特殊设备文件，一些服务支持 Socket 访问，就会产生这样<br>的文件。<br>第 2～4 位代表文件所有者的权限。</li><li>r：代表 read，是读取权限。</li><li>w：代表 write，是写权限。</li><li>x：代表 execute，是执行权限。<br>如果有字母，则代表拥有对应的权限；如果是“-”，则代表没有对应的权限。<br>第 5～7 位代表文件所属组的权限，同样拥有“rwx”权限。<br>第 8～10 位代表其他人的权限，同样拥有“rwx”权限。<br>2．基本权限命令<br>首先来看修改权限的命令 chmod，其基本信息如下。<br>命令名称：chmod。<br>英文原意：change file mode bits。<br>所在路径：/bin/chmod。<br>执行权限：所有用户。<br>功能描述：修改文件的权限模式。</li></ul><p>2.1．命令格式<br>[root@localhost ~]# chmod [选项] 权限模式 文件名 选项：<br>-R： 递归设置权限，也就是给子目录中的所有文件设定权限<br>2.2．权限模式</p><p>———————————————<br>chmod 命令的权限模式的格式是“[ugoa][[+-=][perms]]”，也 就是“[用户身份][[赋予方式][权限]]”<br>的格式，我们来解释一下。<br>用户身份。</p><ul><li>u：代表所有者（user）。</li><li>g：代表所属组（group）。</li><li>o：代表其他人（other）。</li><li>a：代表全部身份（all）。<br>赋予方式。</li><li>+：加入权限。</li><li>-：减去权限。</li><li>=：设置权限。<br>权限。</li><li>r：读取权限（read）。</li><li>w：写权限（write）。</li><li>x：执行权限（execute）。</li></ul><p>2.3．数字权限<br>数字权限的赋予方式是最简单的，但是不如之前的字母权限好记、直观。我们来看看这些数字权<br>限的含义。<br>4：代表“r”权限。<br>2：代表“w”权限。<br>1：代表“x”权限。<br>2.4．常用权限<br>数字权限的赋予方式更加简单，但是需要用户对这几个数字更加熟悉。其实常用权限也并不多，<br>只有如下几个。<br>644：这是文件的基本权限，代表所有者拥有读、写权限，而所属组和其他人拥有只读权限。<br>755：这是文件的执行权限和目录的基本权限，代表所有者拥有读、写和执行权限，而所属组<br>和其他人拥有读和执行权限。<br>777：这是最大权限。在实际的生产服务器中，要尽力避免给文件或目录赋予这样的权限，这<br>会造成一定的安全隐患。<br>3．基本权限的作用<br>3.1．权限含义的解释<br>首先，读、写、执行权限对文件和目录的作用是不同的。<br>权限对文件的作用。</p><ul><li>读（r）：对文件有读（r）权限，代表可以读取文件中的数据。如果把权限对应到命令上，<br>那么一旦对文件有读（r）权限，就可以对文件执行 cat、more、less、head、tail 等文件查<br>看命令。</li><li>写（w）：对文件有写（w）权限，代表可以修改文件中的数据。如果把权限对应到命令上，<br>那么一旦对文件有写（w）权限，就可以对文件执行 vim、echo 等修改文件数据的命令。注</li></ul><p>———————————————<br>意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据。如果要想删除文件，<br>则需要对文件的上级目录拥有写权限。</p><ul><li>执行（x）：对文件有执行（x）权限，代表文件拥有了执行权限，可以运行。在 Linux 中，<br>只要文件有执行（x）权限，这个文件就是执行文件了。只是这个文件到底能不能正确执行，<br>不仅需要执行（x）权限，还要看文件中的代码是不是正确的语言代码。对文件来说，执行<br>（x）权限是最高权限。<br>权限对目录的作用。</li><li>读（r）：对目录有读（r）权限，代表可以查看目录下的内容，也就是可以查看目录下有哪<br>些子文件和子目录。如果把权限对应到命令上，那么一旦对目录拥有了读（r）权限，就可<br>以在目录下执行 ls 命令，查看目录下的内容了。</li><li>写（w）：对目录有写（r）权限，代表可以修改目录下的数据，也就是可以在目录中新建、<br>删除、复制、剪切子文件或子目录。如果把权限对应到命令上，那么一旦对目录拥有了写（w）<br>权限，就可以在目录下执行 touch、rm、cp、mv 命令。对目录来说，写（w）权限是最高<br>权限。</li><li>执行（x）：目录是不能运行的，那么对目录拥有执行（x）权限，代表可以进入目录。如果<br>把权限对应到命令上，那么一旦对目录拥有了执行（x）权限，就可以对目录执行 cd 命令，进入<br>目录。</li></ul><p>3.1．目录的可用权限<br>目录的可用权限其实只有以下几个。<br>0：任何权限都不赋予。<br>5：基本的目录浏览和进入权限。<br>7：完全权限。<br>4．所有者和所属组命令<br>4.1．chown 命令<br>chown 是修改文件和目录的所有者和所属组的命令，其基本信息如下。<br>命令名称：chown。<br>英文原意：change file owner and group。<br>所在路径：/bin/chown。<br>执行权限：所有用户。<br>功能描述：修改文件和目录的所有者和所属组。<br>1）命令格式<br>[root@localhost ~]# chown [选项] 所有者:所属组 文件或目录 选项：<br>-R： 递归设置权限，也就是给子目录中的所有文件设置权限<br>普通用户不能修改文件的所有者，哪怕自己是这个文件的所有者也不行。<br>普通用户可以修改所有者是自己的文件的权限。</p><p>————————————————<br>4.2．chgrp 命令<br>chgrp 是修改文件和目录的所属组的命令，其基本信息如下。<br>命令名称：chgrp。<br>英文原意：change group ownership。<br>所在路径：/bin/chgrp。<br>执行权限：所有用户。<br>功能描述：修改文件和目录的所属组。<br>5．umask 默认权限<br>5.1 查看系统的 umask 权限<br>[root@localhost ~]# umask<br>0022<br>#用八进制数值显示 umask权限<br>[root@localhost ~]# umask -S<br>u=rwx,g=rx,o=rx<br>#用字母表示文件和目录的初始权限<br>.2 umask 权限的计算方法<br>我们需要先了解一下新建文件和目录的默认最大权限。<br>对文件来讲，新建文件的默认最大权限是 666，没有执行（x）权限。这是因为执行权限对文件<br>来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。<br>对目录来讲，新建目录的默认最大权限是 777。这是因为对目录而言，执行（x）权限仅仅代表<br>进入目录，所以即使建立新文件时直接默认赋予，也没有什么危险。<br>按照官方的标准算法，umask 默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到<br>正确的新建文件和目录的默认权限。这种方法既不好计算，也不好理解，超哥并不推荐。<br>我们在这里还是按照权限字母来讲解 umask 权限的计算方法。我们就按照默认的 umask 值是 022<br>来分别计算一下新建文件和目录的默认权限吧。<br>文件的默认权限最大只能是 666，而 umask 的值是 022<br>“-rw-rw-rw-”减去 “—–w–w-”等于“-rw-r–r—”<br>目录的默认权限最大可以是 777，而 umask 的值是 022<br>“drwxrwxrwx”减去“d—-w–w-”等于“drwx-r-xr-x”<br>注意：umask 默认权限的计算绝不是数字直接相减。<br>例如 umask 是 033 呢？<br>文件的默认权限最大只能是 666，而 umask 的值是 033<br>“-rw-rw-rw-”减去“—–wx-wx”等于“-rw-r–r—”</p><p>———————————————<br>六 帮助命令<br>1．man 命令<br>man 是最常见的帮助命令，也是 Linux 最主要的帮助命令，其基本信息如下。<br>命令名称：man。<br>英文原意：format and display the on-line manual pages。<br>所在路径：/usr/bin/man。<br>执行权限：所有用户。<br>功能描述：显示联机帮助手册。<br>1.1．命令格式<br>[root@localhost ~]# man [选项] 命令 选项：<br>-f： 查看命令拥有哪个级别的帮助<br>-k： 查看和命令相关的所有帮助<br>1.2．man 命令的快捷键<br>快 捷 键 作 用<br>上箭头 向上移动一行<br>下箭头 向下移动一行<br>PgUp 向上翻一页<br>PgDn 向下翻一页<br>g 移动到第一页<br>G 移动到最后一页<br>q 退出<br>/字符串 从当前页向下搜索字符串<br>?字符串 从当前页向上搜索字符串<br>n 当搜索字符串时，可以使用 n 键找到下一个字符串<br>N 当搜索字符串时，使用 N 键反向查询字符串。也就是说，如果使用“/字符串”方式搜索，则 N 键<br>表示向上搜索字符串；如果使用“?字符串”方式搜索，则 N 键表示向下搜索字符串<br>1.3．man 命令的帮助级别<br>级 别 作 用<br>1 普通用户可以执行的系统命令和可执行文件的帮助<br>2 内核可以调用的函数和工具的帮助<br>3 C 语言函数的帮助<br>4 设备和特殊文件的帮助<br>5 配置文件的帮助<br>6 游戏的帮助（个人版的 Linux 中是有游戏的）<br>7 杂项的帮助<br>8 超级用户可以执行的系统命令的帮助<br>9 内核的帮助</p><p>————————————————<br>man -f 命令 或 whatis 命令<br>#查看命令拥有哪个级别的帮助<br>man -k 命令 或 apropos 命令<br>#查看和命令相关的所有帮助<br>2．info 命令<br>info 命令的帮助信息是一套完整的资料，每个单独命令的帮助信息只是这套完整资料中的某一<br>个小章节。<br>快 捷 键 作 用<br>上箭头 向上移动一行<br>下箭头 向下移动一行<br>PgUp 向上翻一页<br>PgDn 向下翻一页<br>Tab 在有“<em>”符号的节点间进行切换<br>回车 进入有“</em>”符号的子页面，查看详细帮助信息<br>u 进入上一层信息（回车是进入下一层信息）<br>n 进入下一小节信息<br>p 进入上一小节信息<br>？ 查看帮助信息<br>q 退出 info 信息<br>3．help 命令<br>help 只能获取 Shell 内置命令的帮助<br>help 命令的基本信息如下。<br>命令名称：help。<br>英文原意：help。<br>所在路径：Shell 内置命令。<br>执行权限：所有用户。<br>功能描述：显示 Shell 内置命令的帮助。可以使用 type 命令来区分内置命令与外部命令<br>shell 是 Linux 的命令解释器。<br>4．–help 选项<br>绝大多数命令都可以使用“–help”选项来查看帮助，这也是一种获取帮助的方法。例如：<br>[root@localhost ~]# ls –help<br>这种方法非常简单，输出的帮助信息基本上是 man 命令的信息简要版。<br>对于这 4 种常见的获取帮助的方法，大家可以按照自己的习惯任意使用。</p><p>七 搜索命令<br>1．whereis 命令<br>whereis 是搜索系统命令的命令（像绕口令一样），也就是说，whereis 命令不能搜索普通文件，<br>而只能搜索系统命令。whereis 命令的基本信息如下。<br>命令名称：whereis。<br>英文原意：locate the binary, source, and manual page files for a command。<br>所在路径：/usr/bin/whereis。<br>执行权限：所有用户。<br>功能描述：查找二进制命令、源文件和帮助文档的命令。<br>2．which 命令<br>which 也是搜索系统命令的命令。和 whereis 命令的区别在于：<br>whereis 命令可以在查找到二进制命令的同时，查找到帮助文档的位置；<br>而 which 命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。<br>which 命令的基本信息如下。<br>命令名称：which。<br>英文原意：shows the full path of (shell) commands。<br>所在路径：/usr/bin/which。<br>执行权限：所有用户。<br>功能描述：列出命令的所在路径。<br>3．locate 命令<br>3.1 基本用法<br>locate 命令才是可以按照文件名搜索普通文件的命令。<br>优点：按照数据库搜索，搜索速度快，消耗资源小。数据库位置/var/lib/mlocate/mlocate.db，<br>可以使用 updatedb 命令强制更新数据库。<br>缺点：只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改<br>时间等搜索文件。<br>locate 命令的基本信息如下。<br>命令名称：locate。<br>英文原意：find files by name。<br>所在路径：/usr/bin/locate。</p><p>———————————————<br>执行权限：所有用户。<br>功能描述：按照文件名搜索文件。<br>3.2 配置文件<br>[root@localhost ~]# vi /etc/updatedb.conf<br>PRUNE_BIND_MOUNTS = “yes”<br>#开启搜索限制，也就是让这个配置文件生效<br>PRUNEFS = “……”<br>#在 locate执行搜索时，禁止搜索这些文件系统类型<br>PRUNENAMES = “……”<br>#在 locate执行搜索时，禁止搜索带有这些扩展名的文件<br>PRUNEPATHS = “……”<br>#在 locate执行搜索时，禁止搜索这些系统目录<br>4．find 命令<br>find 命令的基本信息如下。<br>命令名称：find。<br>英文原意：search for files in a directory hierarchy。<br>所在路径：/bin/find。<br>执行权限：所有用户。<br>功能描述：在目录中搜索文件。<br>4.1 按照文件名搜索<br>[root@localhost ~]# find 搜索路径 [选项] 搜索内容 选项：<br>-name： 按照文件名搜索<br>-iname： 按照文件名搜索，不区分文件名大小写<br>-inum： 按照 inode号搜索<br>4.2．按照文件大小搜索<br>[root@localhost ~]# find 搜索路径 [选项] 搜索内容 选项：<br>-size [+|-]大小： 按照指定大小搜索文件<br>这里的“+”的意思是搜索比指定大小还要大的文件，“-”的意思是搜索比指定大小还要小的文<br>件。<br>find 命令的单位：<br>[root@localhost ~]# man find<br>-size n[cwbkMG]<br>File uses n units of space. The following suffixes can be used:<br>‘b’ for 512-byte blocks (this is the default if no suffix is used)<br>#这是默认单位，如果单位为 b或不写单位，则按照 512 Byte搜索</p><p>—————————————<br>‘c’ for bytes<br>#搜索单位是 c，按照字节搜索<br>‘w’ for two-byte words<br>#搜索单位是 w，按照双字节（中文）搜索<br>‘k’ for Kilobytes (units of 1024 bytes)<br>#按照 KB单位搜索，必须是小写的 k<br>‘M’ for Megabytes (units of 1048576 bytes)<br>#按照 MB单位搜索，必须是大写的 M<br>‘G’ for Gigabytes (units of 1073741824 bytes)<br>#按照 GB单位搜索，必须是大写的 G<br>4.3 按照修改时间搜索<br>Linux 中的文件有访问时间（atime）、数据修改时间（mtime）、状态修改时间（ctime）这三个<br>时间，我们也可以按照时间来搜索文件。<br>[root@localhost ~]# find 搜索路径 [选项] 搜索内容 选项：<br>-atime [+|-]时间： 按照文件访问时间搜索<br>-mtime [+|-]时间： 按照文件数据修改时间搜索<br>-ctime [+|-]时间： 按照文件状态修改时间搜索<br>这三个时间的区别我们在 stat 命令中已经解释过了，这里用 mtime 数据修改时间来举例，重点说<br>说“[+-]”时间的含义。<br>-5：代表 5 天内修改的文件。<br>5：代表前 5～6 天那一天修改的文件。<br>+5：代表 6 天前修改的文件。<br>我们画一个时间轴，来解释一下，如图 4-6 所示。<br>4.4 按照权限搜索<br>命令格式。<br>[root@localhost ~]# find 搜索路径 [选项] 搜索内容 选项：<br>-perm 权限模式： 查找文件权限刚好等于“权限模式”的文件<br>-perm -权限模式：查找文件权限全部包含“权限模式”的文件<br>-perm +权限模式：查找文件权限包含“权限模式”的任意一个权限的文件<br>4.5 按照所有者和所属组搜索<br>[root@localhost ~]# find 搜索路径 [选项] 搜索内容 选项：</p><p>—————————————<br>-uid 用户 ID： 按照用户 ID查找所有者是指定 ID的文件<br>-gid 组 ID： 按照用户组 ID查找所属组是指定 ID的文件<br>-user 用户名： 按照用户名查找所有者是指定用户的文件<br>-group 组名： 按照组名查找所属组是指定用户组的文件<br>-nouser： 查找没有所有者的文件<br>按照所有者和所属组搜索时，“-nouser”选项比较常用，主要用于查找垃圾文件。<br>只有一种情况例外，那就是外来文件。比如光盘和 U 盘中的文件如果是由 Windows 复制的，在<br>Linux 中查看就是没有所有者的文件；再比如手工源码包安装的文件，也有可能没有所有者<br>4.6 按照文件类型搜索<br>[root@localhost ~]# find 搜索路径 [选项] 搜索内容 选项：<br>-type d： 查找目录<br>-type f： 查找普通文件<br>-type l： 查找软链接文件<br>4.7 逻辑运算符<br>[root@localhost ~]# find 搜索路径 [选项] 搜索内容 选项：<br>-a： and逻辑与<br>-o： or逻辑或<br>-not： not逻辑非<br>1）-a：and 逻辑与<br>find 命令也支持逻辑运算符选项，其中-a 代表逻辑与运算，也就是-a 的两个条件都成立，find 搜<br>索的结果才成立。举个例子：<br>[root@localhost ~]# find . -size +2k -a -type f #在当前目录下搜索大于 2KB，并且文件类型是普通文件的文件<br>2）-o：or 逻辑或<br>-o 选项代表逻辑或运算，也就是-o 的两个条件只要其中一个成立，find 命令就可以找到结果。例<br>如：<br>[root@localhost ~]# find . -name cangls -o -name bols<br>./cangls<br>./bols<br>#在当前目录下搜索文件名要么是 cangls的文件，要么是 bols的文件<br>3）-not：not 逻辑非<br>-not 是逻辑非，也就是取反的意思。举个例子：<br>[root@localhost ~]# find . -not -name cangls #在当前目录下搜索文件名不是 cangls的文件<br>4.8 其他选项</p><p>———————————————<br>1）-exec 选项<br>这里我们主要讲解两个选项“-exec”和“-ok”，这两个选项的基本作用非常相似。我们先来看<br>看“-exec”选项的格式。<br>[root@localhost ~]# find 搜索路径 [选项] 搜索内容 -exec 命令 2 {} ;<br>其次，这个选项的作用其实是把 find 命令的结果交给由“-exec”调用的命令 2 来处理。“{}”就<br>代表 find 命令的查找结果。<br>2）-ok 选项<br>“-ok”选项和“-exec”选项的作用基本一致，区别在于：“-exec”的命令 2 会直接处理，而不询<br>问；“-ok”的命令 2 在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行。<br>5．grep 命令：补充命令<br>grep 的作用是在文件中提取和匹配符合条件的字符串行。命令格式如下：<br>[root@localhost ~]# grep [选项] “搜索内容” 文件名 选项：<br>-i： 忽略大小写<br>-n： 输出行号 -v： 反向查找<br>–color=auto: 搜索出的关键字用颜色显示<br>find 也是搜索命令，那么 find 命令和 grep 命令有什么区别呢？<br>1）find 命令<br>find 命令用于在系统中搜索符合条件的文件名，如果需要模糊查询，则使用通配符进行匹配，通配符<br>是完全匹配（find 命令可以通过-regex 选项，把匹配规则转为正则表达式规则，但是不建议如此）。<br>2）grep 命令<br>grep 命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式进行匹配，<br>正则表达式是包含匹配。<br>3）通配符与正则表达式的区别<br>通配符：用于匹配文件名，完全匹配<br>通 配 符 作 用<br>? 匹配一个任意字符</p><ul><li>匹配 0 个或任意多个任意字符，也就是可以匹配任何内容<br>[] 匹配中括号中任意一个字符。例如，[abc]代表一定匹配一个字符，或者是 a，或者是 b，或者是 c<br>[-] 匹配中括号中任意一个字符，-代表一个范围。例如，[a-z]代表匹配一个小写字母<br>[^] 逻辑非，表示匹配不是中括号内的一个字符。例如，[^0-9]代表匹配一个不是数字的字符<br>正则表达式：用于匹配字符串，包含匹配<br>正 则 符 作 用</li></ul><p>—————————————————————————————<br>? 匹配前一个字符重复 0 次，或 1 次（?是扩展正则，需要使用 egrep 命令）</p><ul><li>匹配前一个字符重复 0 次，或任意多次<br>[] 匹配中括号中任意一个字符。例如，[abc]代表一定匹配一个字符，或者是 a，或者是 b，或者是 c<br>[-] 匹配中括号中任意一个字符，-代表一个范围。例如，[a-z]代表匹配一个小写字母<br>[^] 逻辑非，表示匹配不是中括号内的一个字符。例如，[^0-9]代表匹配一个不是数字的字符<br>^ 匹配行首<br>$ 匹配行尾<br>6．管道符：补充命令<br>命令格式： 命令 1 | 命令 2<br>命令 1 的正确输出作为命令 2 的操作对象<br>1）例子 1：<br>举个例子，我们经常需要使用“ll”命令查看文件的长格式，不过在有些目录中文件众多，比如/etc/<br>目录，使用“ll”命令显示的内容就会非常多，只能看到最后的内容，而不能看到前面输出的内容。<br>这时我们马上想到 more 命令可以分屏显示文件内容，可是怎么让 more 命令分屏显示命令的输出呢？<br>我想到了一种笨办法：<br>[root@localhost ~]# ll -a /etc/ &gt; /root/testfile<br>#用输出重定向，把 ll命令的输出保存到/root/testfile文件中<br>[root@localhost ~]# more /root/testfile<br>#既然 testfile是文件，当然可以用 more命令分屏显示了<br>总用量 1784<br>drwxr-xr-x. 105 root root 12288 10月 21 12:49 .<br>dr-xr-xr-x. 26 root root 4096 6月 5 19:06 ..<br>…省略部分输出…</li></ul><p>-rwxr-xr-x. 1 root root 687 6月 22 2012 auto.smb<br>–More–(7%)<br>可是这样操作实在不方便，这时就可以利用管道符了。命令如下：<br>[root@localhost ~]# ll -a /etc/ | more<br>2）例子 2：<br>我想在命令 ll /etc/的结果中搜索 yum 的文件名，应该使用 find 命令？还是 grep 命令？<br>[root@localhost ~]# ll -a /etc/ | grep yum<br>3）例子 3：<br>netstat 命令（CentOS 7 中，需要安装 net-snmp.x86_64，net-tools.x86_64 两个包才有此命令。7.5<br>系统中已经自动安装）格式如下：<br>[root@localhost ~]# netstat [选项] 选项：</p><p>—————————————————————————————<br>-a： 列出所有网络状态，包括 Socket程序<br>-c 秒数： 指定每隔几秒刷新一次网络状态<br>-n： 使用 IP地址和端口号显示，不使用域名与服务名<br>-p： 显示 PID和程序名<br>-t： 显示使用 TCP协议端口的连接状况<br>-u： 显示使用 UDP协议端口的连接状况<br>-l： 仅显示监听状态的连接<br>-r： 显示路由表<br>[root@localhost <del>]# netstat -an | grep “ESTABLISHED” | wc -l #如果想知道具体的网络连接数量，就可以再使用 wc命令统计行数<br>统计正在连接的网络连接数量<br>7．命令的别名：补充命令<br>命令的别名，就是命令的小名，主要是用于照顾管理员使用习惯的。<br>命令格式：<br>[root@localhost ~]# alias<br>#查询命令别名<br>[root@localhost ~]# alias 别名=’原命令’<br>#设定命令别名<br>例如：<br>[root@localhost ~]# alias ser=’service network restart’<br>#用 ser别名，替代 service network restart命令<br>用命令定义的别名，是临时生效的，要想永久生效，需要写入环境变量配置文件</del>/.bashrc<br>8．常用快捷键：补充命令<br>快捷键 作 用<br>Tab键 命令或文件补全<br>ctrl+A 把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移<br>动到命令行开头时使用。<br>ctrl+E 把光标移动到命令行结尾。<br>ctrl+C 强制终止当前的命令。<br>ctrl+L 清屏，相当于 clear命令。<br>ctrl+U 删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退<br>格键一个一个字符的删除，使用这个快捷键会更加方便<br>ctrl+Y 粘贴 ctrl+U剪切的内容。<br>八 压缩和解压缩命令<br>在 Linux 中可以识别的常见压缩格式有十几种，比如“.zip”“.gz”“.bz2”“.tar”“.tar.gz”“.tar.bz2”<br>等。</p><p>—————————————————————————————<br>1．“.zip”格式<br>“.zip”是 Windows 中最常用的压缩格式，Linux 也可以正确识别“.zip”格式，这可以方便地和<br>Windows 系统通用压缩文件。<br>1.1．“.zip”格式的压缩命令<br>压缩命令就是 zip，其基本信息如下。<br>命令名称：zip。<br>英文原意：package and compress (archive) files。<br>所在路径：/usr/bin/zip。<br>执行权限：所有用户。<br>功能描述：压缩文件或目录。<br>命令格式如下：<br>[root@localhost ~]# zip [选项] 压缩包名 源文件或源目录 选项：<br>-r： 压缩目录 例如：<br>[root@localhost ~]# zip ana.zip anaconda-ks.cfg<br>1.2．“.zip”格式的解压缩命令<br>“.zip”格式的解压缩命令是 unzip，其基本信息如下。<br>命令名称：unzip。<br>英文原意：list, test and extract compressed files in a ZIP archive。<br>所在路径：/usr/bin/unzip。<br>执行权限：所有用户。<br>功能描述：列表、测试和提取压缩文件中的文件。<br>命令格式如下：<br>[root@localhost ~]# unzip [选项] 压缩包名 选项：<br>-d： 指定解压缩位置 例如：<br>[root@localhost ~]# unzip -d /tmp/ ana.zip #把压缩包解压到指定位置<br>2．“.gz”格式 不会打包<br>2.1．“.gz”格式的压缩命令<br>“.gz”格式是 Linux 中最常用的压缩格式，使用 gzip 命令进行压缩，其基本信息如下。<br>命令名称：gzip。<br>英文原意：compress or expand files。</p><p>—————————————————————————————<br>所在路径：/bin/gzip。<br>执行权限：所有用户。<br>功能描述：压缩文件或目录。<br>这个命令的格式如下：<br>[root@localhost ~]# gzip [选项] 源文件 选项：<br>-c： 将压缩数据输出到标准输出中，可以用于保留源文件<br>-d： 解压缩<br>-r： 压缩目录<br>[root@localhost ~]# gzip -c anaconda-ks.cfg &gt; anaconda-ks.cfg.gz<br>#使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中<br>#这样可以在压缩文件的同时不删除源文件<br>2．“.gz”格式的解压缩命令<br>如果要解压缩“.gz”格式，那么使用“gzip -d 压缩包”和“gunzip 压缩包”命令都可以。我们<br>先看看 gunzip 命令的基本信息。<br>命令名称：gunzip。<br>英文原意：compress or expand files。<br>所在路径：/bin/gunzip。<br>执行权限：所有用户。<br>功能描述：解压缩文件或目录。 例如：<br>[root@localhost ~]# gunzip install.log.gz<br>[root@localhost ~]# gzip -d anaconda-ks.cfg.gz<br>两个命令都可以解压缩“.gz”格式<br>3．“.bz2”格式 不能压缩目录<br>3.1．“.bz2”格式的压缩命令<br>“.bz2”格式是 Linux 的另一种压缩格式，从理论上来讲，“.bz2”格式的算法更先进、压缩比更<br>好；而“.gz”格式相对来讲压缩的时间更快。<br>“.bz2”格式的压缩命令是 bzip2，我们来看看这个命令的基本信息。<br>命令名称：bzip2。<br>英文原意：a block-sorting file compressor。<br>所在路径：/usr/bin/bzip2。<br>执行权限：所有用户。<br>功能描述：.bz2 格式的压缩命令。<br>来看看 bzip2 命令的格式。<br>[root@localhost ~]# bzip2 [选项] 源文件 选项：</p><p>—————————————————————————————<br>-d： 解压缩<br>-k： 压缩时，保留源文件<br>-v： 显示压缩的详细信息<br>例如：<br>[root@localhost ~]# bzip2 anaconda-ks.cfg #压缩成.bz2格式<br>[root@localhost ~]# bzip2 -k install.log.syslog #保留源文件压缩<br>3.2．“.bz2”格式的解压缩命令<br>“.bz2”格式可以使用“bzip2 -d 压缩包”命令来进行解压缩，也可以使用“bunzip2 压缩包”命<br>令来进行解压缩。先看看 bunzip2 命令的基本信息。<br>命令名称：bunzip2。<br>英文原意：a block-sorting file compressor。<br>所在路径：/usr/bin/bunzip2。<br>执行权限：所有用户。<br>功能描述：.bz2 格式的解压缩命令。<br>[root@localhost ~]# bunzip2 anaconda-ks.cfg.bz2<br>[root@localhost ~]# bzip2 -d install.log.syslog.bz2 #两个命令都可以解压缩<br>4．“.tar”格式 打包不会压缩<br>4.1．“.tar”格式的打包命令<br>“.tar”格式的打包和解打包都使用 tar 命令，区别只是选项不同。我们先看看 tar 命令的基本信息。<br>命令名称：tar。<br>英文原意：tar。<br>所在路径：/bin/tar。<br>执行权限：所有用户。<br>功能描述：打包与解打包命令。<br>命令的基本格式如下：<br>[root@localhost ~]# tar [选项] [-f 压缩包名] 源文件或目录 选项：<br>-c： 打包<br>-f： 指定压缩包的文件名。压缩包的扩展名是用来给管理员识别格式的，所以一定<br>要正确指定扩展名 -v： 显示打包文件过程<br>[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg #打包，不会压缩</p><p>—————————————————————————————<br>4.2．“.tar”格式的解打包命令<br>“.tar”格式的解打包也需要使用 tar 命令，但是选项不太一样。命令格式如下：<br>[root@localhost ~]# tar [选项] 压缩包 选项：<br>-x： 解打包<br>-f： 指定压缩包的文件名 -v： 显示解打包文件过程<br>-t： 测试，就是不解打包，只是查看包中有哪些文件<br>-C(大) 目录：指定解打包位置<br>例如<br>[root@localhost ~]# tar -xvf anaconda-ks.cfg.tar #解打包到当前目录下<br>5．“.tar.gz”和“.tar.bz2”格式<br>使用 tar 命令直接打包压缩。命令格式如下：<br>[root@localhost ~]# tar [选项] 压缩包 源文件或目录 选项：<br>-z： 压缩和解压缩“.tar.gz”格式<br>-j： 压缩和解压缩“.tar.bz2”格式<br>例如：.tar.gz格式<br>[root@localhost ~]# tar -zcvf tmp.tar.gz /tmp/ #把/tmp/目录直接打包压缩为“.tar.gz”格式 [root@localhost ~]# tar -zxvf tmp.tar.gz<br>#解压缩与解打包“.tar.gz”格式<br>例如：.tar.bz2格式<br>[root@localhost ~]# tar -jcvf tmp.tar.bz2 /tmp/ #打包压缩为“.tar.bz2”格式，注意压缩包文件名 [root@localhost ~]# tar -jxvf tmp.tar.bz2<br>#解压缩与解打包“.tar.bz2”格式<br>再举几个例子：<br>[root@localhost ~]# mkdir test<br>[root@localhost ~]# touch test/abc<br>[root@localhost ~]# touch test/bcd<br>[root@localhost ~]# touch test/cde #建立测试目录和测试文件<br>[root@localhost ~]# tar -zcvf test.tar.gz test/ #压缩<br>[root@localhost ~]# tar -ztvf test.tar.gz</p><p>—————————————————————————————<br>#只查看，不解压<br>[root@localhost ~]# tar -zxvf test.tar.gz -C /tmp #解压缩到指定位置<br>[root@localhost ~]# tar -zxvf test.tar.gz -C /tmp test/cde #只解压压缩包中的特定文件，到指定位置<br>九 关机和重启命令<br>1．sync 数据同步<br>sync 命令的基本信息如下。<br>命令名称：sync。<br>英文原意：flush file system buffers。<br>所在路径：/bin/sync。<br>执行权限：所有用户。<br>功能描述：刷新文件系统缓冲区。<br>2．shutdown 命令<br>shutdown 命令的基本信息如下。<br>命令名称：shutdown。<br>英文原意：bring the system down。<br>所在路径：/sbin/shutdown。<br>执行权限：超级用户。<br>功能描述：关机和重启<br>命令的基本格式如下：<br>[root@localhost ~]# shutdown [选项] 时间 [警告信息] 选项：<br>-c： 取消已经执行的 shutdown命令<br>-h： 关机 -r： 重启<br>3．reboot 命令<br>在现在的系统中，reboot 命令也是安全的，而且不需要加入过多的选项。<br>[root@localhost ~]# reboot #重启<br>4．halt 和 poweroff 命令<br>这两个都是关机命令，直接执行即可。这两个命令不会完整关闭和保存系统的服务，不建议使用。<br>[root@localhost ~]# halt #关机<br>[root@localhost ~]# poweroff #关机</p><p>————————————————————————————<br>5．init 命令<br>init 是修改 Linux 运行级别的命令，也可以用于关机和重启。这个命令并不安全，不建议使用。<br>[root@localhost ~]# init 0 #关机，也就是调用系统的 0级别 [root@localhost ~]# init 6 #重启，也就是调用系统的 6级别<br>十 常用网络命令<br>1．配置 IP 地址<br>1.1 配置 IP 地址<br>IP 地址是计算机在互联网中唯一的地址编码。每台计算机如果需要接入网络和其他计算机进行数<br>据通信，就必须配置唯一的公网 IP 地址。<br>配置 IP 地址有两种方法：<br>1）setup 工具<br>2）vi /etc/sysconfig/network-scripts/ifcfg-eth0<br>手工修改配置文件<br>1.2 重启网络服务<br>[root@localhost ~]# service network restart #重启网络服务<br>1.3 虚拟机需要桥接到有线网卡，病重启网络服务<br>1.4 复制镜像有可能需要重置 UUID（唯一识别符）<br>[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0 #删除 MAC地址行<br>[root@localhost ~]# rm -rf /etc/udev/rules.d/70-persistent-net.rules #删除 MaC地址和 UUID绑定文件<br>[root@localhost ~]# reboot #重启 Linux<br>2．ifconfig 命令<br>命令名称：ifconfig。</p><p>—————————————————————————————<br>英文原意：configure a network interface。<br>所在路径：/sbin/ifconfig。<br>执行权限：超级用户。<br>功能描述：配置网络接口。<br>ifconfig 命令最主要的作用就是查看 IP 地址的信息，直接输入 ifconfig 命令即可。<br>[root@localhost ~]# ifconfig<br>eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500<br>#标志 最大传输单元<br>inet 192.168.252.20 netmask 255.255.255.0 broadcast 192.168.252.255<br>#IP地址 子网掩码 广播地址<br>inet6 fe80::546e:994b:30c:e2f7 prefixlen 64 scopeid 0x20<link><br>#IPv6地址（目前没有生效）<br>ether 00:0c:29:aa:d2:96 txqueuelen 1000 (Ethernet)<br>#MAC地址<br>RX packets 3728 bytes 310958 (303.6 KiB)<br>RX errors 0 dropped 0 overruns 0 frame 0<br>#接收的数据包情况<br>TX packets 3051 bytes 1495119 (1.4 MiB)<br>TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0<br>#发送的数据包情况<br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 #本地回环网卡<br>inet 127.0.0.1 netmask 255.0.0.0<br>inet6 ::1 prefixlen 128 scopeid 0x10<host><br>loop txqueuelen 1000 (Local Loopback)<br>RX packets 8 bytes 696 (696.0 B)<br>RX errors 0 dropped 0 overruns 0 frame 0<br>TX packets 8 bytes 696 (696.0 B)<br>TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0<br>3．ping 命令<br>ping 是常用的网络命令，主要通过 ICMP 协议进行网络探测，测试网络中主机的通信情况。ping<br>命令的基本信息如下。<br>命令名称：ping。<br>英文原意：send ICMP ECHO_REQUEST to network hosts。<br>所在路径：/bin/ping。<br>执行权限：所有用户。<br>功能描述：向网络主机发送 ICMP 请求。<br>命令的基本格式如下：<br>[root@localhost ~]# ping [选项] IP 选项：<br>-b： 后面加入广播地址，用于对整个网段进行探测<br>-c 次数： 用于指定 ping的次数<br>-s 字节： 指定探测包的大小</host></p><p>—————————————————————————————<br>例子：探测网段中的可用主机<br>在 ping 命令中，可以使用“-b”选项，后面加入广播地址，探测整个网段。我们可以使用这个选<br>项知道整个网络中有多少主机是可以和我们通信的，而不用一个一个 IP 地址地进行探测。例如：<br>[root@localhost ~]# ping -b -c 3 192.168.103.255<br>WARNING: pinging broadcast address<br>PING 192.168.103.255 (192.168.103.255) 56(84) bytes of data.<br>64 bytes from 192.168.103.199: icmp_seq=1 ttl=64 time=1.95 ms<br>64 bytes from 192.168.103.168: icmp_seq=1 ttl=64 time=1.97 ms (DUP!)<br>64 bytes from 192.168.103.252: icmp_seq=1 ttl=64 time=2.29 ms (DUP!) …省略部分内容…<br>#探测 192.168.103.0/24 网段中有多少可以通信的主机<br>4．netstat 命令<br>netstat 是网络状态查看命令，既可以查看到本机开启的端口，也可以查看有哪些客户端连接。<br>在 CentOS 7.x 中 netstat 命令默认没有安装，如果需要使用，需要安装 net-snmp 和 net-tools 软件包。<br>netstat 命令的基本信息如下。<br>命令名称：netstat。<br>英文原意：Print network connections, routing tables, interface statistics, masquerade connections,<br>and multicast memberships。<br>所在路径：/bin/netstat。<br>执行权限：所有用户。<br>功能描述：输出网络连接、路由表、接口统计、伪装连接和组播成员。<br>命令格式如下：<br>[root@localhost ~]# netstat [选项] 选项：<br>-a： 列出所有网络状态，包括 Socket程序<br>-c 秒数： 指定每隔几秒刷新一次网络状态<br>-n： 使用 IP地址和端口号显示，不使用域名与服务名<br>-p： 显示 PID和程序名<br>-t： 显示使用 TCP协议端口的连接状况<br>-u： 显示使用 UDP协议端口的连接状况<br>-l： 仅显示监听状态的连接<br>-r： 显示路由表<br>例子 1：查看本机开启的端口<br>这是本机最常用的方式，使用选项“-tuln”。因为使用了“-l”选项，所以只能看到监听状态的<br>连接，而不能看到已经建立连接状态的连接。例如：<br>[root@localhost ~]# netstat -tuln<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN<br>tcp 0 0 0.0.0.0:11211 0.0.0.0:* LISTEN<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN<br>tcp 0 0 :::11211 :::* LISTEN</p><p>材<br>—————————————————————————————<br>tcp 0 0 :::80 :::* LISTEN<br>tcp 0 0 :::22 :::* LISTEN<br>udp 0 0 0.0.0.0:11211 0.0.0.0:*<br>udp 0 0 :::11211 :::*<br>#协议 接收队列 发送队列 本机的 IP地址及端口号 远程主机的 IP地址及端口号 状态<br>这个命令的输出较多。<br>Proto：网络连接的协议，一般就是 TCP 协议或者 UDP 协议。<br>Recv-Q：表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走。<br>Send-Q：表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，一般是不具备 ACK<br>标志的数据包。<br>Local Address：本机的 IP 地址和端口号。<br>Foreign Address：远程主机的 IP 地址和端口号。<br>State：状态。常见的状态主要有以下几种。</p><ul><li>LISTEN：监听状态，只有 TCP 协议需要监听，而 UDP 协议不需要监听。</li><li>ESTABLISHED：已经建立连接的状态。如果使用“-l”选项，则看不到已经建立连接的状态。</li><li>SYN_SENT：SYN 发起包，就是主动发起连接的数据包。</li><li>SYN_RECV：接收到主动连接的数据包。</li><li>FIN_WAIT1：正在中断的连接。</li><li>FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认。</li><li>TIME_WAIT：连接已经中断，但是套接字依然在网络中等待结束。</li><li>CLOSED：套接字没有被使用。<br>在这些状态中，我们最常用的就是 LISTEN 和 ESTABLISHED 状态，一种代表正在监听，另一种<br>代表已经建立连接。<br>例子 2：查看本机有哪些程序开启的端口<br>如果使用“-p”选项，则可以查看到是哪个程序占用了端口，并且可以知道这个程序的 PID。例<br>如：<br>[root@localhost ~]# netstat -tulnp<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name<br>tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 2359/mysqld<br>tcp 0 0 0.0.0.0:11211 0.0.0.0:* LISTEN 1563/memcached<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1490/sshd<br>tcp 0 0 :::11211 :::* LISTEN 1563/memcached<br>tcp 0 0 :::80 :::* LISTEN 21025/httpd<br>tcp 0 0 :::22 :::* LISTEN 1490/sshd<br>udp 0 0 0.0.0.0:11211 0.0.0.0:* 1563/memcached<br>udp 0 0 :::11211 :::* 1563/memcached #比之前的命令多了一个“-p”选项，结果多了“PID/程序名”，可以知道是哪个程序占用了端口<br>例子 3：查看所有连接<br>使用选项“-an”可以查看所有连接，包括监听状态的连接（LISTEN）、已经建立连接状态的<br>连接（ESTABLISHED）、Socket 程序连接等。因为连接较多，所以输出的内容有很多。例如：</li></ul><p>—————————————————————————————<br>[root@localhost ~]# netstat -an<br>Active Internet connections (servers and established)<br>Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN<br>tcp 0 0 0.0.0.0:11211 0.0.0.0:* LISTEN<br>tcp 0 0 117.79.130.170:80 78.46.174.55:58815 SYN_RECV<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN<br>tcp 0 0 117.79.130.170:22 124.205.129.99:10379 ESTABLISHED<br>tcp 0 0 117.79.130.170:22 124.205.129.99:11811 ESTABLISHED …省略部分内容…<br>udp 0 0 0.0.0.0:11211 0.0.0.0:*<br>udp 0 0 :::11211 :::*<br>Active UNIX domain sockets (servers and established)<br>Proto RefCnt Flags Type State I-Node Path<br>unix 2 [ ACC ] STREAM LISTENING 9761 @/var/run/hald/dbus-fr41WkQn1C …省略部分内容…<br>从“Active UNIX domain sockets”开始，之后的内容就是 Socket 程序产生的连接，之前的内容都是网<br>络服务产生的连接。我们可以在“-an”选项的输出中看到各种网络连接状态，而之前的“-tuln”选项<br>则只能看到监听状态。<br>5．write 命令<br>write 命令的基本信息如下。<br>命令名称：write。<br>英文原意：send a message to another user。<br>所在路径：/usr/bin/write。<br>执行权限：所有用户。<br>功能描述：向其他用户发送信息。<br>[root@localhost ~]#write user1 pts/1<br>hello<br>I will be in 5 minutes to restart, please save your data<br>#向在 pts/1（远程终端 1）登录的 user1用户发送信息，使用“Ctrl+D”快捷键保存发送的数据<br>6．wall 命令<br>write 命令用于给指定用户发送信息，而 wall 命令用于给所有登录用户发送信息，包括你自己。<br>执行时，在 wall 命令后加入需要发送的信息即可，例如：<br>[root@localhost ~]# wall “I will be in 5 minutes to restart, please save your data”<br>7．mail 命令<br>mail 是 Linux 的邮件客户端命令，可以利用这个命令给其他用户发送邮件。mail 命令的基本信息<br>如下。<br>命令名称：mail。<br>英文原意：send and receive Internet mail。</p><p>—————————————————————————————<br>所在路径：/bin/mail。<br>执行权限：所有用户。<br>功能描述：发送和接收电子邮件。<br>例子 1：发送邮件<br>如果我们想要给其他用户发送邮件，则可以执行如下命令：<br>[root@localhost ~]# mail user1 Subject: hello &lt;- 邮件标题<br>Nice to meet you! &lt;- 邮件具体内容<br>. &lt;- 使用“.”来结束邮件输入<br>#发送邮件给 user1用户<br>我们接收到的邮件都保存在“/var/spool/mail/用户名”中，每个用户都有一个以自己的用户名命名<br>的邮箱。<br>例子 2：发送文件内容<br>如果我们想把某个文件的内容发送给指定用户，则可以执行如下命令：<br>[root@localhost ~]# mail -s “test mail” root &lt; /root/anaconda-ks.cfg 选项：<br>-s： 指定邮件标题<br>#把/root/anaconda-ks.cfg文件的内容发送给 root用户<br>我们在写脚本时，有时需要脚本自动发送一些信息给指定用户，把要发送的信息预先写到文件中，<br>是一个非常不错的选择。<br>例子 3：查看已经接收的邮件<br>我们可以直接在命令行中执行 mail 命令，进入 mail 的交互命令中，可以在这里查看已经接收到<br>的邮件。例如：<br>[root@localhost ~]# mail<br>Heirloom Mail version 12.4 7/29/08.Type ?for help.<br>“/var/spool/mail/root”: 1 message 1 new</p><blockquote><p>N 1 root Mon Dec 5 22:45 68/1777 “test mail”&lt;-之前收到的邮件<br>N 2 root Mon Dec 5 23:08 18/602 “hello” #未阅读 编号 发件人 时间 标题<br>&amp; &lt;-等待用户输入命令<br>可以看到已经接收到的邮件列表，“N”代表未读邮件，如果是已经阅读过的邮件，则前面是不<br>会有这个“N”的；之后的数字是邮件的编号，我们主要通过这个编号来进行邮件的操作。如果我们<br>想要查看第一封邮件，则只需输入邮件的编号“1”就可以了。<br>在交互命令中执行“？”，可以查看这个交互界面支持的命令。例如：<br>&amp; ? &lt;-输入命令<br>mail commands<br>type<message list>type messages<br>next goto and type next message<br>from<message list>give head lines of messages<br>headers print out active message headers</message></message></p></blockquote><p>—————————————————————————————<br>delete<message list>delete messages<br>undelete<message list>undelete messages<br>save<message list>folder append messages to folder and mark as saved<br>copy<message list>folder append messages to folder without marking them<br>write<message list>file append message texts to file, save attachments<br>preserve<message list>keep incoming messages in mailbox even if saved<br>Reply<message list>reply to message senders<br>reply<message list>reply to message senders and all recipients<br>mail addresses mail to specific recipients<br>file folder change to another folder<br>quit quit and apply changes to folder<br>xit quit and discard changes made to folder<br>! shell escape<br>cd<directory>chdir to directory or home if none given<br>list list names of all available commands<br>这些交互命令是可以简化输入的，比如“headers”命令，就可以直接输入“h”，这是列出邮件<br>标题列表的命令。我们解释一下常用的交互命令。<br>headers：列出邮件标题列表，直接输入“h”命令即可。<br>delete：删除指定邮件。比如想要删除第二封邮件，可以输入“d 2”。<br>save：保存邮件。可以把指定邮件保存成文件，如“s 2 /tmp/test.mail”。<br>quit：退出，并把已经操作过的邮件进行保存。比如移除已删除邮件、保存已阅读邮件等。<br>exit：退出，但是不保存任何操作。<br>十一 系统痕迹命令<br>系 统 中 有 一 些 重 要 的 痕 迹 日 志 文 件 ， 如 /var/log/wtmp 、 /var/run/utmp 、 /var/log/btmp 、<br>/var/log/lastlog 等日志文件，如果你用 vim 打开这些文件，你会发现这些文件是二进制乱码。这是由<br>于这些日志中保存的是系统的重要登录痕迹，包括某个用户何时登录了系统，何时退出了系统，错误<br>登录等重要的系统信息。这些信息要是可以通过 vim 打开，就能编辑，这样痕迹信息就不准确，所以<br>这些重要的痕迹日志，只能通过对应的命令来进行查看。<br>1．w 命令<br>w 命令是显示系统中正在登陆的用户信息的命令，这个命令查看的痕迹日志是/var/run/utmp。这<br>个命令的基本信息如下：<br>命令名称：w<br>英文原意：Show who is logged on and what they are doing.<br>所在路径：/usr/bin/w<br>执行权限：所有用户。<br>功能描述：显示灯用户，和他正在做什么。<br>例如：</directory></message></message></message></message></message></message></message></message></p><p>—————————————————————————————<br>[root@localhost ~]# w<br>00:06:11 up 5:47, 2 users, load average: 0.00, 0.01, 0.05<br>#系统时间 持续开机时间 登陆用户 系统在 1分钟，5分钟，15分钟前的平均负载<br>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT<br>root tty1 23:59 7:07 0.08s 0.08s -bash<br>root pts/2 192.168.252.1 23:42 3.00s 0.44s 0.06s w<br>第一行信息，内容如下：<br>内 容 说 明<br>12:26:46 系统当前时间<br>up 1 day, 13:32 系统的运行时间，本机已经运行 1 天 13 小时 32 分钟<br>2 users 当前登录了两个用户<br>系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值<br>load average: 0.00, 0.00, 0.00 超过 1 就是高负载；如果 CPU 是四核的，则这个数值超过 4 就是高负载<br>（这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU<br>的核数）<br>第二行信息，内容如下：<br>内 容 说 明<br>USER 当前登陆的用户<br>TTY 登陆的终端：<br>tty1-6：本地字符终端（alt+F1-6切换）<br>tty7：本地图形终端（ctrl+alt+F7切换，必须安装启动图形界面）<br>pts/0-255:远程终端<br>FROM 登陆的 IP地址，如果是本地终端，则是空<br>LOGIN@ 登陆时间<br>IDLE 用户闲置时间<br>JCPU 所有的进程占用的 CPU时间<br>PCPU 当前进程占用的 CPU时间<br>WHAT 用户正在进行的操作<br>2．who 命令<br>who 命令和 w 命令类似，用于查看正在登陆的用户，但是显示的内容更加简单，也是查看<br>/var/run/utmp 日志。<br>[root@localhost ~]# who<br>root tty1 2018-11-12 23:59<br>root pts/2 2018-11-12 23:42 (192.168.252.1) #用户名 登陆终端 登陆时间（来源 IP）</p><p>—————————————————————————————<br>3．last 命令<br>last 命令是查看系统所有登陆过的用户信息的，包括正在登陆的用户和之前登陆的用户。这个命<br>令查看的是/var/log/wtmp 痕迹日志文件。<br>[root@localhost ~]# last<br>root tty1 Mon Nov 12 23:59 still logged in<br>root pts/2 192.168.252.1 Mon Nov 12 23:42 still logged in<br>root pts/1 192.168.252.1 Mon Nov 12 23:37 - 23:59 (00:22)<br>root tty1 Mon Nov 12 19:17 - 23:58 (04:41)<br>root pts/0 192.168.252.1 Mon Nov 12 18:20 - 23:52 (05:32)<br>reboot system boot 3.10.0-862.el7.x Mon Nov 12 18:18 - 00:22 (06:03) #系统重启信息记录<br>root pts/1 192.168.252.1 Mon Nov 12 08:48 - down (01:29)<br>root pts/1 192.168.252.1 Thu Nov 8 21:04 - 22:29 (01:25) #用户名 终端号 来源 IP地址 登陆时间 - 退出时间<br>4．lastlog 命令<br>lastlog 命令是查看系统中所有用户最后一次的登陆时间的命令，他查看的日志是/var/log/lastlog<br>文件。<br>[root@localhost ~]# lastlog<br>Username Port From Latest<br>root tty1 Mon Nov 12 23:59:03 +0800 2018<br>bin <strong>Never logged in</strong><br>daemon <strong>Never logged in</strong><br>adm <strong>Never logged in</strong><br>lp <strong>Never logged in</strong><br>sync <strong>Never logged in</strong><br>…省略部分内容…<br>#用户名 终端 来源 IP 登陆时间<br>5．lastb 命令<br>lastb 命令是查看错误登陆的信息的，查看的是/var/log/btmp 痕迹日志：<br>[root@localhost ~]# lastb<br>(unknown tty1 Mon Nov 12 23:58 - 23:58 (00:00)<br>root tty1 Mon Nov 12 23:58 - 23:58 (00:00) #错误登陆用户 终端 尝试登陆的时间</p><p>—————————————————————————————<br>十二 挂载命令<br>1． mount命令基本格式<br>linux 所有存储设备都必须挂载使用，包括硬盘<br>命令名称：mount<br>命令所在路径：/bin/mount<br>执行权限：所有用户<br>说了这么多，命令的具体格式如下：<br>[root@localhost ~]# mount [-l]<br>#查询系统中已经挂载的设备，-l会显示卷标名称<br>[root@localhost ~]# mount –a<br>#依据配置文件/etc/fstab的内容，自动挂载<br>[root@localhost ~]# mount [-t 文件系统] [-L 卷标名] [-o 特殊选项]<br>设备文件名 挂载点<br>#\代表这一行没有写完，换行<br>选项：<br>-t 文件系统： 加入文件系统类型来指定挂载的类型，可以 ext3、ext4、iso9660<br>等文件系统。具体可以参考表 9-1<br>-L 卷标名： 挂载指定卷标的分区，而不是安装设备文件名挂载<br>-o 特殊选项： 可以指定挂载的额外选项，比如读写权限、同步异步等，如果不指定<br>则默认值生效。具体的特殊选项，见表 9-4：<br>参数 说明<br>atime/noatime 更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时<br>间，默认为更新<br>async/sync 异步/同步，默认为异步<br>auto/noauto 自动/手动，mount –a命令执行时，是否会自动安装/etc/fstab文件内容<br>挂载，默认为自动<br>defaults 定义默认值，相当于 rw,suid,dev,exec,auto,nouser,async这七个选项<br>exec/noexec 执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是 exec<br>允许<br>remount 重新挂载已经挂载的文件系统，一般用于指定修改特殊权限<br>rw/ro 读写/只读，文件系统挂载时，是否具有读写权限，默认是 rw<br>suid/nosuid 具有/不具有 SUID权限，设定文件系统是否具有 SUID和 SGID的权限，默<br>认是具有<br>user/nouser 允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是<br>不允许，只有 root可以挂载分区<br>usrquota 写入代表文件系统支持用户磁盘配额，默认不支持<br>grpquota 写入代表文件系统支持组磁盘配额，默认不支持<br>举例</p><p>—————————————————————————————<br>例 1：<br>[root@localhost ~]# mount<br>#查看系统中已经挂载的文件系统，注意有虚拟文件系统<br>/dev/sda3 on / type ext4 (rw)<br>proc on /proc type proc (rw)<br>sysfs on /sys type sysfs (rw)<br>devpts on /dev/pts type devpts (rw,gid=5,mode=620)<br>tmpfs on /dev/shm type tmpfs (rw)<br>/dev/sda1 on /boot type ext4 (rw)<br>none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)<br>sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)<br>#命令结果是代表：/dev/sda3分区挂载到/目录，文件系统是 ext4，权限是读写<br>例 2：修改特殊权限<br>[root@localhost ~]# mount<br>#我们查看到/boot分区已经被挂载，而且采用的 defaults选项，那么我们重新挂载分区，并采用 noexec<br>#权限禁止执行文件执行，看看会出现什么情况（注意不要用/分区做试验，#不然系统命令也不能执行了）。<br>…省略部分输出…<br>/dev/sda1 on /boot type ext4 (rw)<br>…省略部分输出…<br>[root@localhost ~]# mount -o remount,noexec /boot<br>#重新挂载/boot分区，并使用 noexec权限<br>[root@localhost sh]# cd /boot/<br>[root@localhost boot]# vi hello.sh<br>#写个 shell吧<br>#!/bin/bash<br>echo “hello!!”<br>[root@localhost boot]# chmod 755 hello.sh<br>[root@localhost boot]# ./hello.sh<br>-bash: ./hello.sh: 权限不够<br>#虽然赋予了 hello.sh执行权限，但是任然无法执行<br>[root@localhost boot]# mount -o remount,exec /boot<br>#记得改回来啊，要不会影响系统启动的<br>如果我们做试验修改了特殊选项，一定要记得住，而且确定需要修改，否则非常容易出现系统问<br>题，而且还找不到哪里出现了问题。<br>例 3：挂载分区<br>[root@localhost ~]# mkdir /mnt/disk1<br>#建立挂载点目录<br>[root@localhost ~]# mount /dev/sdb1 /mnt/disk1<br>#挂载分区<br>2. 光盘挂载<br>光盘挂载的前提依然是指定光盘的设备文件名，不同版本的 Linux，设备文件名并不相同：</p><p>—————————————————————————————<br>CentOS 5.x 以前的系统，光盘设备文件名是/dev/hdc<br>CentOS 6.x 以后的系统，光盘设备文件名是/dev/sr0<br>不论哪个系统都有软连接/dev/cdrom，与可以作为光盘的设备文件名<br>[root@localhost ~]# mount -t iso9660 /dev/cdrom /mnt/cdrom/ #挂载光盘<br>用完之后记得卸载：<br>[root@localhost ~]# umount /dev/sr0<br>[root@localhost ~]# umount /mnt/cdrom<br>#因为设备文件名和挂载点已经连接到一起，卸载哪一个都可以<br>注意：卸载的时候需要退出光盘目录，才能正常卸载<br>3. 挂载 U 盘<br>U 盘会和硬盘共用设备文件名，所以 U 盘的设备文件名不是固定的，需要手工查询，查询命令：<br>[root@localhost ~]# fdisk -l #查询硬盘<br>然后就是挂载了，挂载命令如下：<br>[root@localhost ~]# mount -t vfat /dev/sdb1 /mnt/usb/ #挂载 U盘。因为是 Windows分区，所以是 vfat文件系统格式<br>如果 U 盘中有中文，会发现中文是乱码。Linux 要想正常显示中文，需要两个条件：<br>安装了中文编码和中文字体<br>操作终端需要支持中文显示（纯字符终端，是不支持中文编码的）<br>而我们当前系统是安装了中文编码和字体，而 xshell 远程终端是 Windows 下的程序，当然是支持<br>中文显示的。那之所以挂载 U 盘还出现乱码，是需要在挂载的时候，手工指定中文编码，例如：<br>[root@localhost ~]# mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/ #挂载 U盘，指定中文编码格式为 UTF-8<br>如果需要卸载，可以执行以下命令：<br>[root@localhost ~]# umount /mnt/usb/<br>4、挂载 NTFS 分区<br>4.1 Linux 的驱动加载顺序：<br>驱动直接放入系统内核之中。这种驱动主要是系统启动加载必须的驱动，数量较少。<br>驱 动 以 模 块 的 形 式 放 入 硬 盘 。 大 多 数 驱 动 都 已 这 种 方 式 保 存 ， 保 存 位 置 在<br>/lib/modules/3.10.0-862.el7.x86_64/kernel/中。<br>驱动可以被 Linux 识别，但是系统认为这种驱动一般不常用，默认不加载。如果需要加载这<br>种驱动，需要重新编译内核，而 NTFS 文件系统的驱动就属于这种情况。<br>硬件不能被 Linux 内核识别，需要手工安装驱动。当然前提是厂商提供了该硬件针对 Linux<br>的驱动，否则就需要自己开发驱动了。<br>4.2 使用 NTFS-3G安装 NTFS文件系统模块<br>下载 NTFS-3G插件<br>我们从网站 <span class="exturl"><a class="exturl__link" href="http://www.tuxera.com/community/ntfs-3g-download/下载" target="_blank" rel="noopener">http://www.tuxera.com/community/ntfs-3g-download/下载</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> NTFS-3G 插件到 Linux</p><p>—————————————————————————————<br>服务器上。<br>安装 NTFS-3G插件<br>在编译安装 NTFS-3G插件之前，要保证 gcc编译器已经安装。具体安装命令如下：<br>[root@localhost ~]# tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz<br>#解压<br>[root@localhost ~]# cd ntfs-3g_ntfsprogs-2013.1.13<br>#进入解压目录<br>[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# ./configure<br>#编译器准备。没有指定安装目录，安装到默认位置中<br>[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# make<br>#编译<br>[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# make install<br>#编译安装<br>安装就完成了，已经可以挂载和使用 Windows 的 NTFS 分区了。不过需要注意挂载分区时的文件<br>系统不是 ntfs，而是 ntfs-3g。挂载命令如下：<br>[root@localhost ~]# mount -t ntfs-3g 分区设备文件名 挂载点<br>例如：<br>[root@localhost ~]# mount –t ntfs-3g /dev/sdb1 /mnt/win</p></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://bfch.github.io">Anew忘</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://bfch.github.io/2020-10-15/31/">https://bfch.github.io/2020-10-15/31/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2020-09-27/30/"><span class="paginator-prev__text">30</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"></section><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/avatar.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">北风承欢</p></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-email"><a class="sidebar-ov-feed-email__link" href="1463751713@qq.com" target="_blank" rel="noopener"><span class="sidebar-ov-feed-email__icon"><i class="fas fa-envelope"></i></span><span>Email 订阅</span></a></span><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Anew忘</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v4.2.1</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.1</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zindex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function initSearch(){var i=!0,e="search.xml";e?/json$/i.test(e)&&(i=!1):e="search.xml";var t="/"+e;$.ajax({url:t,dataType:i?"xml":"json",async:!0,success:function(e){function t(){var e=o.val().toLowerCase().trim(),x=e.split(/[\s]+/),w=[];1<x.length&&x.push(e),0<e.length&&n.forEach(function(e){var t=!1,n=e.title&&e.title.trim()||"[ 文章无标题 ]",o=n&&n.toLowerCase(),c=e.content&&e.content.replace(/<[^>]+>/g,""),i=c&&c.toLowerCase(),r=e.url&&decodeURI(e.url).replace(/\/{2,}/g,"/"),s=[],a=[];x.forEach(function(e){function t(t,e,n,o){if(!t||!e)return[];var c,i=0,r=[];for(n||(t=t.toLowerCase(),e=e.toLowerCase());-1!==(c=e.indexOf(t,i));){var a=!1;s.forEach(function(e){e.index===c&&e.word.length<t.length&&(e.word=t,a=!0)}),i=c+t.length,a||r.push({index:c,word:t,weight:o})}return r}s=s.concat(t(e,o,!1,y)),a=a.concat(t(e,i,!1,m))});var l,u,h,d,f,p=s.length,v=a.length;function g(n,e,t,o){if(n&&e&&e.length){var c="",i=t,r=o;return e.forEach(function(e){var t;e.index<i||(t=e.index+e.word.length,c+=n.slice(i,e.index),c+="<b>"+n.slice(e.index,t)+"</b>",i=t)}),c+=n.slice(i,r)}}(0<p||0<v)&&(t=!0),t&&([s,a].forEach(function(e){e.sort(function(e,t){return e.index-t.index})}),l={},u=s.length*y+a.length*m,h=g(n,s,0,n.length)||n,f=0<a.length?(d=a[0].index,g(c,a,20<d?d-20:0,d+180)):c.slice(0,200),l.title=h,l.content=f,l.url=r,l.weight=u,w.push(l))});var t="";w.length?(w.sort(function(e,t){return t.weight-e.weight}),t+="<ul>",w.forEach(function(e){t+='<li><a class="search-results-title" href="'+e.url+'">',t+=e.title,t+='</a><div class="search-results-content">',t+=e.content,t+="</div></li>"}),t+="</ul>"):t+='<div class="search-results-none"><i class="far fa-meh"></i></div>',c.html(t)}var n=i?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,o=$(".search-input input"),c=$(".search-results"),y=100,m=1;o.on("input",t),o.on("keyup",function(e){e.keyCode===Stun.utils.codeToKeyCode("Enter")&&t()})}})}function closeSearch(){$("body").css({overflow:"auto"}),$(".search-popup").css({display:"none"}),$(".search-mask").css({display:"none"})}window.addEventListener("DOMContentLoaded",function(){Stun.utils.pjaxReloadLocalSearch=function(){$(".header-nav-search").on("click",function(e){e.stopPropagation(),$("body").css("overflow","hidden"),$(".search-popup").velocity("stop").velocity("transition.expandIn",{duration:300,complete:function(){$(".search-popup input").focus()}}),$(".search-mask").velocity("stop").velocity("transition.fadeIn",{duration:300}),initSearch()}),$(".search-mask, .search-close").on("click",function(){closeSearch()}),$(document).on("keydown",function(e){e.keyCode===Stun.utils.codeToKeyCode("Escape")&&closeSearch()})},Stun.utils.pjaxReloadLocalSearch()},!1)</script><script src="//cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",function(){new Pjax({selectors:["head title","#main",".pjax-reload"],history:!0,scrollTo:!1,scrollRestoration:!1,cacheBust:!1,debug:!1,currentUrlFullReload:!1,timeout:0});var e=null;document.addEventListener("pjax:send",function(){$(".header-nav-menu").removeClass("show"),CONFIG.pjax&&CONFIG.pjax.avoidBanner&&$("html").velocity("scroll",{duration:500,offset:$("#header").height(),easing:"easeInOutCubic"});var a=20;$(".loading-bar").addClass("loading"),$(".loading-bar__progress").css("width",a+"%"),clearInterval(e),e=setInterval(function(){95<(a+=3)&&(a=95),$(".loading-bar__progress").css("width",a+"%")},500)},!1),window.addEventListener("pjax:complete",function(){clearInterval(e),$(".loading-bar__progress").css("width","100%"),$(".loading-bar").removeClass("loading"),setTimeout(function(){$(".loading-bar__progress").css("width","0")},400),$("link[rel=prefetch], script[data-pjax-rm]").each(function(){$(this).remove()}),$("script[data-pjax], #pjax-reload script").each(function(){$(this).parent().append($(this).remove())}),Stun.utils.pjaxReloadBoot&&Stun.utils.pjaxReloadBoot(),Stun.utils.pjaxReloadScroll&&Stun.utils.pjaxReloadScroll(),Stun.utils.pjaxReloadSidebar&&Stun.utils.pjaxReloadSidebar()},!1)},!1)</script><div id="pjax-reload"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>